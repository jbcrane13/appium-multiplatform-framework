"""Base page object class for all platforms."""

from typing import Tuple, Optional, List, Union, Dict
from appium.webdriver.webdriver import WebDriver
from appium.webdriver.webelement import WebElement
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException
from utils.element_finder import RobustElementFinder


class BasePage:
    """
    Platform-agnostic base page object.

    This class provides common functionality that works across iOS and Android.
    Platform-specific behavior is handled via the platform property.
    """

    def __init__(self, driver: WebDriver):
        """
        Initialize base page.

        Args:
            driver: Appium WebDriver instance
        """
        self.driver = driver
        self.platform = driver.capabilities.get('platformName', 'unknown').lower()
        self.default_timeout = 30

        # Initialize RobustElementFinder with shorter timeout for faster failing
        # Page objects can override find methods to use faster accessibility ID searches
        self.finder = RobustElementFinder(driver, default_timeout=3)

    # ===== Locator Helpers =====

    def by_accessibility_id(self, accessibility_id: str) -> Tuple[str, str]:
        """
        Create locator by accessibility ID (works on iOS and Android).

        Args:
            accessibility_id: Accessibility identifier

        Returns:
            Tuple of (By.ACCESSIBILITY_ID, value)
        """
        return (By.ACCESSIBILITY_ID, accessibility_id)

    def by_id(self, element_id: str) -> Tuple[str, str]:
        """
        Create locator by ID.

        Args:
            element_id: Element ID

        Returns:
            Tuple of (By.ID, value)
        """
        return (By.ID, element_id)

    def by_xpath(self, xpath: str) -> Tuple[str, str]:
        """
        Create locator by XPath.

        Args:
            xpath: XPath expression

        Returns:
            Tuple of (By.XPATH, value)
        """
        return (By.XPATH, xpath)

    def by_class_name(self, class_name: str) -> Tuple[str, str]:
        """
        Create locator by class name.

        Args:
            class_name: Class name

        Returns:
            Tuple of (By.CLASS_NAME, value)
        """
        return (By.CLASS_NAME, class_name)

    # iOS-specific locators
    def by_ios_predicate(self, predicate: str) -> Tuple[str, str]:
        """
        Create locator by iOS predicate string (iOS only).

        Args:
            predicate: iOS predicate expression

        Returns:
            Tuple of (By.IOS_PREDICATE, value)
        """
        if self.platform != 'ios':
            raise ValueError("iOS predicates only work on iOS platform")
        return ('-ios predicate string', predicate)

    def by_ios_class_chain(self, class_chain: str) -> Tuple[str, str]:
        """
        Create locator by iOS class chain (iOS only).

        Args:
            class_chain: iOS class chain expression

        Returns:
            Tuple of (By.IOS_CLASS_CHAIN, value)
        """
        if self.platform != 'ios':
            raise ValueError("iOS class chains only work on iOS platform")
        return ('-ios class chain', class_chain)

    # Android-specific locators (for future use)
    def by_android_uiautomator(self, uia_string: str) -> Tuple[str, str]:
        """
        Create locator by Android UIAutomator (Android only).

        Args:
            uia_string: UIAutomator string

        Returns:
            Tuple of (By.ANDROID_UIAUTOMATOR, value)
        """
        if self.platform != 'android':
            raise ValueError("UIAutomator only works on Android platform")
        return ('-android uiautomator', uia_string)

    # ===== Element Finding =====

    def find_element(self, locator: Tuple[str, str], timeout: Optional[int] = None) -> WebElement:
        """
        Find element with wait.

        Args:
            locator: Tuple of (By strategy, value)
            timeout: Custom timeout

        Returns:
            WebElement when found
        """
        timeout = timeout or self.default_timeout
        return WebDriverWait(self.driver, timeout).until(
            EC.presence_of_element_located(locator)
        )

    def find_elements(self, locator: Tuple[str, str], timeout: Optional[int] = None) -> List[WebElement]:
        """
        Find multiple elements with wait.

        Args:
            locator: Tuple of (By strategy, value)
            timeout: Custom timeout

        Returns:
            List of WebElements
        """
        timeout = timeout or self.default_timeout
        return WebDriverWait(self.driver, timeout).until(
            EC.presence_of_all_elements_located(locator)
        )

    def is_element_present(self, locator: Tuple[str, str], timeout: int = 5) -> bool:
        """
        Check if element is present.

        Args:
            locator: Tuple of (By strategy, value)
            timeout: Wait timeout

        Returns:
            True if present
        """
        try:
            self.find_element(locator, timeout=timeout)
            return True
        except TimeoutException:
            return False

    def is_element_visible(self, locator: Tuple[str, str], timeout: int = 5) -> bool:
        """
        Check if element is visible.

        Args:
            locator: Tuple of (By strategy, value)
            timeout: Wait timeout

        Returns:
            True if visible
        """
        try:
            WebDriverWait(self.driver, timeout).until(
                EC.visibility_of_element_located(locator)
            )
            return True
        except TimeoutException:
            return False

    # ===== Element Interactions =====

    def click(self, locator: Tuple[str, str], timeout: Optional[int] = None) -> None:
        """
        Click element with wait.

        Args:
            locator: Tuple of (By strategy, value)
            timeout: Custom timeout
        """
        timeout = timeout or self.default_timeout
        element = WebDriverWait(self.driver, timeout).until(
            EC.element_to_be_clickable(locator)
        )
        element.click()

    def send_keys(self, locator: Tuple[str, str], text: str, clear_first: bool = True, timeout: Optional[int] = None) -> None:
        """
        Send keys to element.

        Args:
            locator: Tuple of (By strategy, value)
            text: Text to enter
            clear_first: Clear field before entering
            timeout: Custom timeout
        """
        element = self.find_element(locator, timeout)
        if clear_first:
            element.clear()
        element.send_keys(text)

    def get_text(self, locator: Tuple[str, str], timeout: Optional[int] = None) -> str:
        """
        Get element text.

        Args:
            locator: Tuple of (By strategy, value)
            timeout: Custom timeout

        Returns:
            Element text
        """
        element = self.find_element(locator, timeout)
        return element.text

    # ===== Robust Element Finding (Fast Path with Fallbacks) =====

    def find_by_accessibility_id(
        self,
        accessibility_id: str,
        fallbacks: Optional[List[Union[str, Dict[str, str]]]] = None,
        timeout: Optional[int] = None
    ) -> WebElement:
        """
        Find element by accessibility ID with optional fallback strategies.

        This method uses the optimized RobustElementFinder which is 29x faster
        than predicate string searches when accessibility IDs are present.

        Args:
            accessibility_id: Primary accessibility identifier
            fallbacks: Optional fallback strategies (predicate strings or dicts)
            timeout: Custom timeout (default: 3 sec for fast failing)

        Returns:
            WebElement when found

        Example:
            # Fast path - no fallback (for stable app elements)
            >>> tab = page.find_by_accessibility_id("dashboard_tab")

            # With fallback (for system dialogs)
            >>> button = page.find_by_accessibility_id(
            ...     "close_button",
            ...     fallbacks=['label == "Close"', 'name == "Close"']
            ... )
        """
        return self.finder.find_by_id(accessibility_id, fallbacks, timeout)

    def wait_for_accessibility_id(
        self,
        accessibility_id: str,
        fallbacks: Optional[List[Union[str, Dict[str, str]]]] = None,
        timeout: int = 10
    ) -> WebElement:
        """
        Explicitly wait for element by accessibility ID (for async content).

        Use this for elements that may take time to appear due to network
        requests, animations, or async data loading.

        Args:
            accessibility_id: Primary accessibility identifier
            fallbacks: Optional fallback strategies
            timeout: Wait timeout (default: 10 sec for async content)

        Returns:
            WebElement when it appears

        Example:
            >>> score = page.wait_for_accessibility_id("condition_score_value", timeout=10)
        """
        return self.finder.wait_for_id(accessibility_id, fallbacks, timeout)

    def is_accessible_element_present(
        self,
        accessibility_id: str,
        timeout: int = 1
    ) -> bool:
        """
        Check if element with accessibility ID is present (fast check).

        Uses short timeout (1 sec) for quick presence checks.

        Args:
            accessibility_id: Accessibility identifier
            timeout: Check timeout (default: 1 sec)

        Returns:
            True if element exists, False otherwise

        Example:
            >>> if page.is_accessible_element_present("system_dialog"):
            ...     page.find_by_accessibility_id("dialog_dismiss").click()
        """
        return self.finder.is_element_present(accessibility_id, timeout)

    # ===== Gestures =====

    def swipe(self, direction: str = 'up', distance: int = 300) -> None:
        """
        Swipe screen.

        Args:
            direction: Direction ('up', 'down', 'left', 'right')
            distance: Swipe distance
        """
        size = self.driver.get_window_size()
        start_x = size['width'] // 2
        start_y = size['height'] // 2

        direction_map = {
            'up': (start_x, start_y - distance),
            'down': (start_x, start_y + distance),
            'left': (start_x - distance, start_y),
            'right': (start_x + distance, start_y)
        }

        end_x, end_y = direction_map.get(direction, (start_x, start_y))
        self.driver.swipe(start_x, start_y, end_x, end_y)

    # ===== App State =====

    def hide_keyboard(self) -> None:
        """Hide keyboard if visible (platform-agnostic)."""
        try:
            self.driver.hide_keyboard()
        except:
            pass  # Keyboard not present

    def is_keyboard_shown(self) -> bool:
        """
        Check if keyboard is shown.

        Returns:
            True if keyboard visible
        """
        return self.driver.is_keyboard_shown()

    # ===== Tab Bar Navigation (iOS) =====

    def tap_tab_by_label(self, tab_label: str, timeout: int = 10) -> None:
        """
        Tap a tab in the iOS tab bar by its label.

        This method uses optimized RobustElementFinder with fast primary search
        and smart fallback strategies.

        Args:
            tab_label: The label text of the tab (e.g., 'Dashboard', 'Map')
            timeout: Wait timeout

        Example:
            >>> page.tap_tab_by_label("Dashboard")
        """
        # PRIMARY: Try direct accessibility ID (fast: ~350ms)
        accessibility_id = f"{tab_label.lower()}_tab"

        # FALLBACKS: Only if primary fails (slower but comprehensive)
        fallbacks = [
            # iOS predicate as fallback
            f'label CONTAINS[c] "{tab_label}" OR name CONTAINS[c] "{tab_label}"',
        ]

        try:
            element = self.find_by_accessibility_id(accessibility_id, fallbacks, timeout=3)
            element.click()
            return
        except:
            # If RobustElementFinder fails, try legacy strategies
            self._find_tab_legacy(tab_label, timeout)

    def _find_tab_legacy(self, tab_label: str, timeout: int) -> None:
        """Legacy fallback for tab finding (kept for compatibility)."""
        strategies = [
            lambda: self._find_in_tab_bar_by_label(tab_label, timeout),
            lambda: self._find_button_by_name(tab_label, timeout),
        ]

        last_error = None
        for strategy in strategies:
            try:
                strategy()
                return
            except Exception as e:
                last_error = e
                continue

        raise last_error if last_error else Exception(f"Could not find tab '{tab_label}'")

    def _find_in_tab_bar_by_label(self, tab_label: str, timeout: int) -> None:
        """Find and tap a button in the tab bar by label."""
        # First find the tab bar
        tab_bar = WebDriverWait(self.driver, timeout).until(
            EC.presence_of_element_located((By.CLASS_NAME, 'XCUIElementTypeTabBar'))
        )

        # Then find the button with matching label
        buttons = tab_bar.find_elements(By.CLASS_NAME, 'XCUIElementTypeButton')
        for button in buttons:
            label = button.get_attribute('label') or button.get_attribute('name')
            if label and tab_label.lower() in label.lower():
                button.click()
                return

        raise Exception(f"Tab '{tab_label}' not found in tab bar")

    def _find_button_by_name(self, tab_label: str, timeout: int) -> None:
        """Find button by name attribute."""
        buttons = WebDriverWait(self.driver, timeout).until(
            EC.presence_of_all_elements_located((By.CLASS_NAME, 'XCUIElementTypeButton'))
        )

        for button in buttons:
            name = button.get_attribute('name')
            if name and tab_label.lower() in name.lower():
                button.click()
                return

        raise Exception(f"Button with name '{tab_label}' not found")

    def _find_by_predicate(self, tab_label: str, timeout: int) -> None:
        """Find element using iOS predicate string."""
        if self.platform != 'ios':
            raise ValueError("Predicates only work on iOS")

        element = WebDriverWait(self.driver, timeout).until(
            EC.element_to_be_clickable((
                '-ios predicate string',
                f'label CONTAINS[c] "{tab_label}" OR name CONTAINS[c] "{tab_label}"'
            ))
        )
        element.click()

    # ===== Modal/Sheet Handling =====

    def dismiss_modal_if_present(self) -> bool:
        """
        Dismiss any open modal or sheet by tapping Done, Close, Cancel, or Back button.

        Uses optimized fast checks with 1-second timeout per button. If no accessibility
        IDs are found, returns False immediately (fail fast). This prevents spending
        40+ seconds searching for non-existent buttons.

        Returns:
            True if a modal was dismissed, False otherwise

        Example:
            >>> page.dismiss_modal_if_present()
        """
        # Common dismiss button texts (in order of likelihood)
        dismiss_texts = ['done', 'close', 'cancel', 'back']

        for accessibility_id in dismiss_texts:
            # FAST CHECK: 1 second timeout per button
            if self.is_accessible_element_present(accessibility_id, timeout=1):
                try:
                    element = self.find_by_accessibility_id(accessibility_id, timeout=1)
                    element.click()
                    return True
                except:
                    continue

        # No modal found - return False immediately (fail fast)
        # Do NOT use slow predicate string searches
        return False

    def dismiss_sheet_by_swipe(self) -> bool:
        """
        Dismiss an iOS sheet by swiping down.

        This is the standard iOS gesture for dismissing sheets that don't have
        explicit dismiss buttons.

        Returns:
            True if swipe was performed, False otherwise

        Example:
            >>> page.dismiss_sheet_by_swipe()
        """
        try:
            if self.platform != 'ios':
                return False

            # Get screen dimensions
            size = self.driver.get_window_size()

            # Swipe down from top-center of screen
            # This mimics the iOS gesture to dismiss sheets
            start_x = size['width'] // 2
            start_y = int(size['height'] * 0.3)  # Start from upper portion of screen
            end_x = start_x
            end_y = int(size['height'] * 0.8)  # Swipe down to lower portion

            self.driver.swipe(start_x, start_y, end_x, end_y, 500)
            return True
        except Exception:
            return False

    def tap_outside_sheet(self) -> bool:
        """
        Tap on the dimmed background area to dismiss a sheet.

        Returns:
            True if tap was performed, False otherwise

        Example:
            >>> page.tap_outside_sheet()
        """
        try:
            if self.platform != 'ios':
                return False

            # Get screen dimensions
            size = self.driver.get_window_size()

            # Tap near top of screen (where dimmed background usually is)
            tap_x = size['width'] // 2
            tap_y = int(size['height'] * 0.15)  # Top 15% of screen

            self.driver.tap([(tap_x, tap_y)])
            return True
        except Exception:
            return False
